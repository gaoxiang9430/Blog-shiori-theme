+++
date = "2016-05-26T21:45:10+08:00"
draft = true
title = "X86汇编语言学习"
tags = [ "Assamble", "blog" ]
+++

X86是intel芯片的指令集，本文中描述了部分常用的x86指令．

<!--more-->

#### 1，XOR亦或 ####
XOR eax，eax；表示将寄存器eax置零
#### 2，Test测试
只设置状态寄存器，不修改寄存器本身，这是与and最本质的区别
test eax,eax;表示如果eax=0，则将Z置1
#### 3、jl 跳转
```cmp eax, 4,   jl short 00412DEF``` 表示如果eax小于4 则发生跳转

#### 4、无号数运算(比较)后使用的条件跳越指令[编辑]

| 指令	| 意义	| 条件
| -----|:----:| ----:|
| je	| 若等于则跳转 	x = y |	ZF=1
|jne	|若不等于则跳越	x≠y|	ZF=0
|ja|若高于则跳越|CF=0且ZF=0
|jnbe|若不低于则跳越	x > y	|CF=0且ZF=0
|jae|若高于或等于则跳越|x≧y	CF=0
|jnb	|若不低于或等于则跳越	|x≧y	CF=0
|jb|若低于则跳越|	x 小于 y	CF=1
|jnae	|若不高于或等于则跳越	x 小于 y	|CF=1
|jbe|若低于或等于则跳越|CF=1或ZF=1
|jna	|若不高于则跳越	x≦y	|CF=1或ZF=1
有号数运算(比较)后使用的条件跳越指令[编辑]

| 指令	| 意义	| 条件
| -----|:----:| ----:|
|je	|若等于则跳越	x = y	|ZF=1
|jne|	若不等于则跳越	x≠y	|ZF=0
|jg|若大于则跳越|ZF=0且SF=OF
|jnle	|若不低于或等于则跳越	x > y	|ZF=0且SF=OF
|jge|若高于于或等于则跳越|SF=OF
|jnl|	若不低于则跳越	x≧y	|SF=OF
|jl|若低于则跳越|SF≠OF
|jngl|若不大于或等于则跳越	x 小于 y	|SF≠OF
|jle|若低于或等于则跳越|ZF=1或SF≠OF
|jng	|若不大于则跳越	x≦y	|ZF=1或SF≠OF

状态判断的条件跳越指令[编辑]

| 指令	| 意义	| 条件
| -----|:----:| ----:|
|jc	|若进位则跳越|	CF=1|
|jnc	|若无进位则跳越|	CF=0|
|js	|若为负数则跳越|	SF=1|
|jns	|若为正数则跳越	|SF=0|
|jz	|若等于0则跳越|	ZF=1
|jnz	|若不等于0则跳越|	ZF=0
|jp	|若同位则跳越|	PF=1
|jnp	|若没有同位则跳越|	PF=0
|jpe	|若偶同位则跳越|	PF=1
|jpo	|若奇同位则跳越|	PF=0
|jo	|若溢出则跳越|	OF=1
|jno	|若没有溢出则跳越|	OF=0

#### 5、X86寄存器： 

X86处理器中有8个32位的通用寄存器。由于历史的原因，EAX通常用于计算，ECX通常用于循环变量计数。ESP和EBP有专门用途，ESP指示栈指针(用于指示栈顶位置)，而EBP则是基址指针（用于指示子程序或函数调用的基址指针）。如图中所示，EAX、EBX、ECX和EDX的前两个高位字节和后两个低位字节可以独立使用，其中两位低字节又被独立分为H和L部分，这样做的原因主要是考虑兼容16位的程序，具体兼容匹配细节请查阅相关文献。
应用寄存器时，其名称大小写是不敏感的，如EAX和eax没有区别。
#### 6、 寻址模式
现代X86处理器具有232字节的寻址空间。在上面的例子中，我们用标签(label)表示内存区域，这些标签在实际汇编时，均被32位的实际地址代替。除了支持这种直接的内存区域描述，X86还提供了一种灵活的内存寻址方式，即利用最多两个32位的寄存器和一个32位的有符号常数相加计算一个内存地址，其中一个寄存器可以左移1、2或3位以表述更大的空间。下面例子是汇编程序中常见的方式
mov eax, [ebx]	; 将ebx值指示的内存地址中的4个字节传送到eax中
mov [var], ebx	; 将ebx的内容传送到var的值指示的内存地址中.
mov eax, [esi-4]	; 将esi-4值指示的内存地址中的4个字节传送到eax中
mov [esi+eax], cl	; 将cl的值传送到esi+eax的值指示的内存地址中
mov edx, [esi+4*ebx]    	; 将esi+4*ebx值指示的内存中的4个字节传送到edx
下面是违反规则的例子:
mov eax, [ebx-ecx]	; 只能用加法
mov [eax+esi+edi], ebx    	; 最多只能有两个寄存器参与运算

#### 7、lea— Load effective address
 lea实际上是一个载入有效地址指令，将第二个操作数表示的地址载入到第一个操作数（寄存器）中。其语法如下所示：
Syntax
	lea reg32,mem
Examples
	lea eax, [var] — var指示的地址载入eax中.
	lea edi, [ebx+4*esi] — ebx+4*esi表示的地址载入到edi中
#### 8、inc, dec— Increment, Decrement
inc,dec分别表示将操作数自加1，自减1，其语法如下所示：
inc reg   inc mem    dec reg    dec mem
#### 9、imul— Integer Multiplication整数相乘
整数相乘指令，它有两种指令格式，一种为两个操作数，将两个操作数的值相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器；第二种格式为三个操作数，其语义为：将第二个和第三个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器。其语法如下所示：
imul reg32,reg32
imul reg32,mem
imul reg32,reg32,con
imul reg32,mem,con
#### 10、idiv— Integer Division 整数除法
idiv指令完成整数除法操作，idiv只有一个操作数，此操作数为除数，而被除数则为EDX:EAX中的内容（一个64位的整数），操作的结果有两部分：商和余数，其中商放在eax寄存器中，而余数则放在edx寄存器中。其语法如下所示：
Syntax
idiv reg32
idiv mem
#### 11、neg— Negate
取负指令。语法为：
neg reg
neg mem
Example： neg eax — EAX → - EAX
#### 12、shl, shr— Shift Left, Shift Right位移指令
位移指令，有两个操作数，第一个操作数表示被操作数，第二个操作数指示位移的数量。其语法如下所示：
shl reg,con8
shl mem,con8
shl reg,cl
shl mem,cl
#### 13、控制转移指令
X86处理器维持着一个指示当前执行指令的指令指针（IP），当一条指令执行后，此指针自动指向下一条指令。IP寄存器不能直接操作，但是可以用控制流指令更新。
一般用标签（label）指示程序中的指令地址，在X86汇编代码中，可以在任何指令前加入标签。如：
       mov esi, [ebp+8]begin: xor ecx, ecx       mov eax, [esi]
#### 13、call, ret— Subroutine call and return 函数调用
这两条指令实现子程序（过程、函数等意思）的调用及返回。call指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。与其它简单的跳转指令不同，call指令保存调用之前的地址信息（当call指令结束后，返回到调用之前的地址）。
ret指令实现子程序的返回机制，ret指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。
call，ret是函数调用中最关键的两条指令。具体细节见下面一部分的讲解。语法为：
call label
Ret
#### 14、段寄存器
X86中的包含了4个段寄存器CS, DS, SS, ES
其中CS表示代码段寄存器，与IP配合CS：IP指向当前运行的指令。需要注意的是CS和IP不能通过mov指令进行修改，要修改IP内容只能通过jmp指令进行。
DS表示数据段寄存器，例如DS=10000H，mov eax，[0] 表示将10000H处的内容放入eax中。
SS表示栈的基地址，而SP表示栈顶，SS：SP指向栈顶。关于潜在的越界访问，可以使用两个寄存器，限制可以访问的栈空间。但是在8086cpu中并没有这样的机制来防止越界，因此在编程的时候要格外注意。 
#### 15、Si和Di
Si和Di是与bx，dx具有相似功能的寄存器，只是si和di不能拆分成两个寄存器使用。只能使用{bx，bp}+{si，di}的方式进行诸如mov ax, [bx]这种方式的寻址。
#### 16、置零操作的位数
在有寄存器的时候，可以通过寄存器的大小指明指令操作的位数，在没有的情况下，用操作符X ptr指明内存的长度，X在汇编中可以是word或byte
